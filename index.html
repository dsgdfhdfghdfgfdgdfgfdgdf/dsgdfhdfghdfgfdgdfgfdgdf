<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Визуальная Новелла</title>
    <style>
        :root {
            --primary-color: #6d4aff;
            --secondary-color: #ff6e9f;
            --dark-color: #2d2b55;
            --light-color: #f8f8f2;
            --shadow-color: rgba(0,0,0,0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: var(--light-color);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Disclaimer Screen */
        #disclaimer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 2rem;
        }

        .disclaimer-content {
            background: var(--dark-color);
            border-radius: 15px;
            padding: 2rem;
            max-width: 600px;
            box-shadow: 0 10px 25px var(--shadow-color);
            text-align: center;
            animation: fadeIn 0.5s ease-out;
        }

        .disclaimer-content h2 {
            color: var(--secondary-color);
            margin-bottom: 1.5rem;
            font-size: 2rem;
        }

        .disclaimer-content p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        /* Settings Screen */
        #settings {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: none;
            z-index: 900;
            overflow-y: auto;
            padding: 2rem;
        }

        .settings-container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(45, 43, 85, 0.8);
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 25px var(--shadow-color);
        }

        .settings-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .settings-header h2 {
            color: var(--secondary-color);
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .settings-tabs {
            display: flex;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 2rem;
        }

        .tab-btn {
            padding: 0.8rem 1.5rem;
            background: none;
            border: none;
            color: var(--light-color);
            font-size: 1rem;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.3s, border-bottom 0.3s;
            border-bottom: 3px solid transparent;
        }

        .tab-btn.active {
            opacity: 1;
            border-bottom: 3px solid var(--secondary-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.8rem;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            color: var(--light-color);
            font-size: 1rem;
        }

        .form-group input[type="range"] {
            width: 100%;
            margin-top: 0.5rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            margin-right: 0.5rem;
        }

        /* Game Screen */
        #game {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            overflow: hidden;
        }

        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: opacity 1s ease;
        }

        #characters {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .character {
            position: absolute;
            bottom: 20%;
            height: 70%;
            transition: all 0.5s ease-out;
            transform-origin: bottom center;
        }

        #dialogue-box {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 900px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 100;
        }

        #speaker {
            color: var(--secondary-color);
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        #dialogue-text {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 1rem;
            min-height: 3rem;
        }

        #choices {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            margin-top: 1rem;
        }

        .choice-btn {
            background: rgba(109, 74, 255, 0.2);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 0.7rem 1.2rem;
            color: var(--light-color);
            cursor: pointer;
            transition: all 0.3s;
            flex-grow: 1;
        }

        .choice-btn:hover {
            background: rgba(109, 74, 255, 0.4);
        }

        #user-input-container {
            display: flex;
            margin-top: 1rem;
        }

        #user-input {
            flex-grow: 1;
            padding: 0.8rem;
            border-radius: 5px 0 0 5px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            color: var(--light-color);
            font-size: 1rem;
        }

        #send-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 0 5px 5px 0;
            padding: 0.8rem 1.5rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        #send-btn:hover {
            background: #5536e0;
        }

        #regenerate-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 110, 159, 0.2);
            border: 1px solid var(--secondary-color);
            color: var(--light-color);
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        #regenerate-btn:hover {
            background: rgba(255, 110, 159, 0.4);
        }

        /* Menu */
        #menu-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 200;
            transition: background 0.3s;
        }

        #menu-button:hover {
            background: rgba(0,0,0,0.8);
        }

        #menu-dropdown {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            width: 300px;
            padding: 1rem;
            z-index: 300;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            display: none;
        }

        #direct-request {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 5px;
            color: var(--light-color);
            padding: 0.8rem;
            resize: none;
            margin-bottom: 0.8rem;
        }

        #send-direct-btn {
            width: 100%;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.7rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        /* Loading indicator */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: var(--secondary-color);
            animation: spin 1s ease-in-out infinite;
        }

        /* Buttons */
        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
        }

        .btn:hover {
            background: #5536e0;
        }

        .btn-secondary {
            background: var(--secondary-color);
        }

        .btn-secondary:hover {
            background: #e84e8a;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Character and resource management */
        .resource-list {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .resource-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .resource-item:last-child {
            border-bottom: none;
        }

        .resource-item-name {
            font-weight: 600;
        }

        .resource-controls {
            display: flex;
            gap: 0.5rem;
        }

        .edit-btn, .delete-btn {
            background: none;
            border: none;
            color: var(--light-color);
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.3s;
        }

        .edit-btn:hover, .delete-btn:hover {
            opacity: 1;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1200;
            display: none;
        }

        .modal-content {
            background: var(--dark-color);
            border-radius: 15px;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-header h3 {
            color: var(--secondary-color);
        }

        .close-modal {
            background: none;
            border: none;
            color: var(--light-color);
            font-size: 1.5rem;
            cursor: pointer;
        }

        /* File upload styles */
        .file-upload {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            background: rgba(0,0,0,0.2);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 1.5rem;
        }

        .file-upload:hover {
            background: rgba(0,0,0,0.3);
            border-color: rgba(255,255,255,0.5);
        }

        .file-upload p {
            margin-top: 0.5rem;
            color: rgba(255,255,255,0.7);
        }

        .image-preview {
            width: 100%;
            height: 200px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 10px;
            margin-top: 1rem;
            background-color: rgba(0,0,0,0.2);
        }

        .system-prompt-editor {
            width: 100%;
            height: 300px;
            font-family: monospace;
            line-height: 1.4;
            font-size: 0.9rem;
        }

        /* Sprite gallery */
        .sprite-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 1rem;
        }

        .sprite-item {
            position: relative;
            width: 100px;
            height: 100px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 5px;
            border: 2px solid rgba(255,255,255,0.2);
            overflow: hidden;
        }

        .sprite-item-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 0.8rem;
            padding: 3px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .background-item {
            position: relative;
            width: 100%;
            height: 150px;
            margin-bottom: 10px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            overflow: hidden;
        }

        .background-item-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            font-weight: bold;
        }

        /* API keys management */
        .api-keys-container {
            margin-bottom: 1.5rem;
        }

        .api-key-item {
            display: flex;
            margin-bottom: 0.5rem;
        }

        .api-key-item input {
            flex-grow: 1;
            padding: 0.8rem;
            border-radius: 5px 0 0 5px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            color: var(--light-color);
        }

        .api-key-item button {
            background: rgba(255, 110, 159, 0.2);
            border: none;
            border-radius: 0 5px 5px 0;
            padding: 0.8rem;
            color: var(--light-color);
            cursor: pointer;
        }

        #add-api-key-btn {
            width: 100%;
            background: rgba(109, 74, 255, 0.2);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 0.7rem;
            color: var(--light-color);
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 0.5rem;
        }

        #add-api-key-btn:hover {
            background: rgba(109, 74, 255, 0.4);
        }
    </style>
</head>
<body>
    <!-- Disclaimer Screen -->
    <div id="disclaimer">
        <div class="disclaimer-content">
            <h2>Пользовательское соглашение</h2>
            <p>Добро пожаловать в LLM Визуальную Новеллу!</p>
            <p>Разработчик этого приложения не является профессиональным программистом. Большая часть кода была написана с помощью искусственного интеллекта Claude 3.7 от Anthropic.</p>
            <p>Разработчик не несёт ответственности за содержание, генерируемое LLM, возможные технические проблемы или любые другие последствия использования данного приложения.</p>
            <p>Все персонажи в игре старше 21 года. При добавлении собственных персонажей вы обязуетесь использовать изображения только совершеннолетних персонажей.</p>
            <p>Используя это приложение, вы подтверждаете, что не будете использовать его для создания или распространения незаконного или неприемлемого контента.</p>
            <p>Это некоммерческий проект, созданный исключительно в развлекательных и образовательных целях.</p>
            <button class="btn btn-secondary" id="accept-btn">Затерпеть</button>
        </div>
    </div>

    <!-- Settings Screen -->
    <div id="settings">
        <div class="settings-container">
            <div class="settings-header">
                <h2>Настройки новеллы</h2>
                <p>Настройте параметры игры перед началом</p>
            </div>
            
            <div class="settings-tabs">
                <button class="tab-btn active" data-tab="general">Основные</button>
                <button class="tab-btn" data-tab="characters">Персонажи</button>
                <button class="tab-btn" data-tab="locations">Локации</button>
                <button class="tab-btn" data-tab="story">Сюжет</button>
                <button class="tab-btn" data-tab="system">Системный промпт</button>
            </div>
            
            <div class="tab-content active" id="general-tab">
                <div class="form-group">
                    <label for="model-select">Модель LLM (в формате OpenRouter)</label>
                    <input type="text" id="model-select" value="google/gemini-2.0-flash-thinking-exp:free">
                </div>
                
                <div class="form-group">
                    <label>API Ключи OpenRouter (один на строку)</label>
                    <div class="api-keys-container" id="api-keys-container">
                        <div class="api-key-item">
                            <input type="text" class="api-key-input" placeholder="sk-or-...">
                            <button class="remove-api-key-btn">✕</button>
                        </div>
                    </div>
                    <button id="add-api-key-btn">Добавить API ключ</button>
                </div>
                
                <div class="form-group">
                    <label for="temperature">Креативность (температура): <span id="temp-value">0.2</span></label>
                    <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.2">
                </div>
                
                <div class="form-group">
                    <label for="max-tokens">Максимальное количество токенов в ответе</label>
                    <input type="number" id="max-tokens" value="30000" min="1000" max="100000">
                </div>
                
                <div class="form-group">
                    <label>Режимы игры</label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="romance-mode">
                        <label for="romance-mode">Романтика</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="cute-mode">
                        <label for="cute-mode">Милота</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="cringe-mode">
                        <label for="cringe-mode">Кринжовый режим</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="story-mode">
                        <label for="story-mode">Сюжетный режим (7 дней)</label>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="characters-tab">
                <div class="resource-list" id="character-list">
                    <!-- Characters will be populated here -->
                </div>
                
                <button class="btn" id="add-character-btn">Добавить персонажа</button>
                <button class="btn" id="scan-characters-btn">Сканировать персонажей</button>
            </div>
            
            <div class="tab-content" id="locations-tab">
                <div class="resource-list" id="location-list">
                    <!-- Locations will be populated here -->
                </div>
                
                <button class="btn" id="add-location-btn">Добавить локацию</button>
                <button class="btn" id="scan-locations-btn">Сканировать фоны</button>
            </div>
            
            <div class="tab-content" id="story-tab">
                <div class="form-group">
                    <label for="story-title">Название истории</label>
                    <input type="text" id="story-title" placeholder="Летний лагерь">
                </div>
                
                <div class="form-group">
                    <label for="story-description">Описание сюжета</label>
                    <textarea id="story-description" rows="4" placeholder="Опишите основную идею сюжета..."></textarea>
                </div>
                
                <div class="form-group">
                    <label>Ключевые события (для сюжетного режима)</label>
                    <div id="events-container">
                        <div class="form-group">
                            <input type="text" class="story-event" placeholder="Событие, которое должно произойти...">
                        </div>
                    </div>
                    <button class="btn" id="add-event-btn">Добавить событие</button>
                </div>
            </div>
            
            <div class="tab-content" id="system-tab">
                <div class="form-group">
                    <label for="system-prompt">Системный промпт</label>
                    <textarea id="system-prompt" class="system-prompt-editor"></textarea>
                </div>
                <button class="btn" id="reset-prompt-btn">Сбросить к стандартному</button>
            </div>
            
            <div style="text-align: center; margin-top: 2rem;">
                <button class="btn btn-secondary" id="start-game-btn">Начать игру</button>
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game">
        <div id="background"></div>
        <div id="characters"></div>
        
        <div id="dialogue-box">
            <div id="speaker"></div>
            <div id="dialogue-text"></div>
            <div id="choices"></div>
            
            <div id="user-input-container">
                <input type="text" id="user-input" placeholder="Введите свой ответ...">
                <button id="send-btn">Отправить</button>
            </div>
            
            <button id="regenerate-btn">Перегенерировать</button>
        </div>
        
        <div id="menu-button">☰</div>
        <div id="menu-dropdown">
            <textarea id="direct-request" placeholder="Прямой запрос к LLM..."></textarea>
            <button id="send-direct-btn">Отправить запрос</button>
        </div>
    </div>

    <!-- Character Modal -->
    <div class="modal" id="character-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Редактирование персонажа</h3>
                <button class="close-modal">&times;</button>
            </div>
            
            <div class="form-group">
                <label for="character-name">Имя персонажа</label>
                <input type="text" id="character-name">
            </div>
            
            <div class="form-group">
                <label for="character-description">Описание персонажа</label>
                <textarea id="character-description" rows="4"></textarea>
            </div>
            
            <div class="form-group">
                <label>Загрузить изображение персонажа</label>
                <div class="file-upload" id="character-upload">
                    <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    <p>Нажмите или перетащите файл</p>
                </div>
                <input type="file" id="character-file" style="display: none" accept="image/*" multiple>
                <div class="image-preview" id="character-preview"></div>
            </div>
            
            <div class="form-group">
                <label>Эмоции персонажа</label>
                <div class="sprite-gallery" id="character-sprites">
                    <!-- Sprites will be added here -->
                </div>
            </div>
            
            <button class="btn" id="save-character-btn">Сохранить</button>
        </div>
    </div>

    <!-- Location Modal -->
    <div class="modal" id="location-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Редактирование локации</h3>
                <button class="close-modal">&times;</button>
            </div>
            
            <div class="form-group">
                <label for="location-name">Название локации</label>
                <input type="text" id="location-name">
            </div>
            
            <div class="form-group">
                <label for="location-description">Описание локации</label>
                <textarea id="location-description" rows="4"></textarea>
            </div>
            
            <div class="form-group">
                <label>Загрузить изображение локации</label>
                <div class="file-upload" id="location-upload">
                    <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    <p>Нажмите или перетащите файл</p>
                </div>
                <input type="file" id="location-file" style="display: none" accept="image/*">
                <div class="image-preview" id="location-preview"></div>
            </div>
            
            <button class="btn" id="save-location-btn">Сохранить</button>
        </div>
    </div>

    <!-- Loading spinner -->
    <div id="loading">
        <div class="spinner"></div>
    </div>

    <script>
        // Default system prompt
        const DEFAULT_SYSTEM_PROMPT = `Ты являешься искусственным интеллектом, управляющим интерактивной визуальной новеллой. Твоя задача - создавать увлекательное повествование, управлять персонажами, сценами и развитием сюжета на основе выборов игрока.

### ФОРМАТ ОТВЕТОВ

Отвечай ИСКЛЮЧИТЕЛЬНО в JSON-формате:

{
  "messages": [
    {
      "text": "Текст диалога или повествования",
      "speaker": "имя_персонажа или narrator",
      "emotion": "эмоция_персонажа",
      "background": "фон_если_меняется",
      "sound": "звуковой_эффект_если_нужен",
      "position": "left/center/right",
      "choices": ["вариант1", "вариант2"]
    }
  ],
  "internal_notes": "Заметки для себя, не показываются игроку",
  "resource_request": {
    "type": "character/background/sound",
    "name": "имя_ресурса",
    "description": "описание_как_должен_выглядеть"
  }
}

### ДОСТУПНЫЕ РЕСУРСЫ

## Персонажи
{{CHARACTERS_LIST}}

## Фоны
{{BACKGROUNDS_LIST}}

### ПАРАМЕТРЫ ИСТОРИИ

Название: {{STORY_TITLE}}
Описание: {{STORY_DESCRIPTION}}
Текущий день: {{CURRENT_DAY}} {{STORY_MODE_ENABLED}}

{{MODE_INSTRUCTIONS}}

### ПРАВИЛА ПОВЕСТВОВАНИЯ

- Создавай эмоционально насыщенные диалоги, соответствующие характеру персонажей
- Развивай историю последовательно, учитывая предыдущие выборы игрока
- Предлагай выборы в ключевых моментах (не более 2-4 вариантов)
- Используй смену фонов для обозначения перемещений между локациями
- Меняй эмоции персонажей в соответствии с ситуацией
- Персонажи могут находиться в разных позициях: left, center, right

### СЖАТАЯ ИСТОРИЯ ПРЕДЫДУЩИХ СОБЫТИЙ
{{COMPRESSED_HISTORY}}

### НАЧАЛО ИСТОРИИ

Начни историю с прибытия в пионерский лагерь. Представь главного персонажа (игрока) и хотя бы одного второстепенного персонажа. Опиши обстановку, создай интригу или цель, которая будет мотивировать игрока продолжать историю.

### ОГРАНИЧЕНИЯ

- Все персонажи старше 21 года
- Не нарушай установленный сеттинг и жанр
- Отвечай строго в указанном JSON-формате для корректной работы игры`;

        // Game State
        const gameState = {
            characters: {},
            backgrounds: {},
            currentBackground: "",
            activeCharacters: {},
            dialogue: [],
            context: [],
            focusWindow: [], // Last 5 messages for context retention
            compressedHistory: "", // Compressed history of older messages
            settings: {
                model: "google/gemini-2.0-flash-thinking-exp:free",
                apiKeys: [""],
                currentKeyIndex: 0,
                temperature: 0.2,
                maxTokens: 30000,
                modes: {
                    romance: false,
                    cuteness: false,
                    cringe: false,
                    story: false
                },
                storyTitle: "",
                storyDescription: "",
                storyEvents: [],
                systemPrompt: DEFAULT_SYSTEM_PROMPT
            },
            gameDay: 1,
            waitingForResponse: false,
            lastResponse: null,
            userResources: {
                characters: {},
                backgrounds: {}
            }
        };

        // DOM Elements
        const elements = {
            // Screens
            disclaimer: document.getElementById('disclaimer'),
            settings: document.getElementById('settings'),
            game: document.getElementById('game'),
            
            // Settings elements
            modelSelect: document.getElementById('model-select'),
            apiKeysContainer: document.getElementById('api-keys-container'),
            temperature: document.getElementById('temperature'),
            tempValue: document.getElementById('temp-value'),
            maxTokens: document.getElementById('max-tokens'),
            romanceMode: document.getElementById('romance-mode'),
            cuteMode: document.getElementById('cute-mode'),
            cringeMode: document.getElementById('cringe-mode'),
            storyMode: document.getElementById('story-mode'),
            storyTitle: document.getElementById('story-title'),
            storyDescription: document.getElementById('story-description'),
            characterList: document.getElementById('character-list'),
            locationList: document.getElementById('location-list'),
            eventsContainer: document.getElementById('events-container'),
            systemPrompt: document.getElementById('system-prompt'),
            
            // Game elements
            background: document.getElementById('background'),
            characters: document.getElementById('characters'),
            speaker: document.getElementById('speaker'),
            dialogueText: document.getElementById('dialogue-text'),
            choices: document.getElementById('choices'),
            userInput: document.getElementById('user-input'),
            sendBtn: document.getElementById('send-btn'),
            regenerateBtn: document.getElementById('regenerate-btn'),
            menuButton: document.getElementById('menu-button'),
            menuDropdown: document.getElementById('menu-dropdown'),
            directRequest: document.getElementById('direct-request'),
            sendDirectBtn: document.getElementById('send-direct-btn'),
            
            // Modals
            characterModal: document.getElementById('character-modal'),
            locationModal: document.getElementById('location-modal'),
            
            // Loading
            loading: document.getElementById('loading')
        };

        // Event Listeners
        document.getElementById('accept-btn').addEventListener('click', () => {
            elements.disclaimer.style.display = 'none';
            elements.settings.style.display = 'block';
            loadSettings();
            scanResources();
        });

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all tabs
                document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                
                // Add active class to clicked tab
                btn.classList.add('active');
                document.getElementById(`${btn.dataset.tab}-tab`).classList.add('active');
            });
        });

        // Temperature slider
        elements.temperature.addEventListener('input', () => {
            elements.tempValue.textContent = elements.temperature.value;
        });

        // Start game button
        document.getElementById('start-game-btn').addEventListener('click', () => {
            saveSettings();
            startGame();
        });

        // Menu toggle
        elements.menuButton.addEventListener('click', () => {
            elements.menuDropdown.style.display = elements.menuDropdown.style.display === 'none' ? 'block' : 'none';
        });

        // Add character button
        document.getElementById('add-character-btn').addEventListener('click', () => {
            openCharacterModal();
        });

        // Add location button
        document.getElementById('add-location-btn').addEventListener('click', () => {
            openLocationModal();
        });

        // Add event button
        document.getElementById('add-event-btn').addEventListener('click', () => {
            const eventInput = document.createElement('div');
            eventInput.className = 'form-group';
            eventInput.innerHTML = `<input type="text" class="story-event" placeholder="Событие, которое должно произойти...">`;
            elements.eventsContainer.appendChild(eventInput);
        });

        // Close modal buttons
        document.querySelectorAll('.close-modal').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.style.display = 'none';
                });
            });
        });

        // Save character button
        document.getElementById('save-character-btn').addEventListener('click', saveCharacter);

        // Save location button
        document.getElementById('save-location-btn').addEventListener('click', saveLocation);

        // Send user input
        elements.sendBtn.addEventListener('click', () => sendUserInput());
        elements.userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendUserInput();
        });

        // Regenerate button
        elements.regenerateBtn.addEventListener('click', regenerateResponse);

        // Send direct request
        elements.sendDirectBtn.addEventListener('click', sendDirectRequest);

        // Add API key button
        document.getElementById('add-api-key-btn').addEventListener('click', () => {
            addApiKeyField();
        });

        // Reset system prompt button
        document.getElementById('reset-prompt-btn').addEventListener('click', () => {
            elements.systemPrompt.value = DEFAULT_SYSTEM_PROMPT;
        });

        // Scan buttons
        document.getElementById('scan-characters-btn').addEventListener('click', scanCharacters);
        document.getElementById('scan-locations-btn').addEventListener('click', scanBackgrounds);

        // Character file upload
        document.getElementById('character-upload').addEventListener('click', () => {
            document.getElementById('character-file').click();
        });

        document.getElementById('character-file').addEventListener('change', handleCharacterFileSelect);

        // Character file drop zone
        const characterDropZone = document.getElementById('character-upload');
        characterDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            characterDropZone.style.backgroundColor = 'rgba(0,0,0,0.4)';
        });

        characterDropZone.addEventListener('dragleave', () => {
            characterDropZone.style.backgroundColor = '';
        });

        characterDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            characterDropZone.style.backgroundColor = '';
            handleCharacterFileDrop(e);
        });

        // Location file upload
        document.getElementById('location-upload').addEventListener('click', () => {
            document.getElementById('location-file').click();
        });

        document.getElementById('location-file').addEventListener('change', handleLocationFileSelect);

        // Location file drop zone
        const locationDropZone = document.getElementById('location-upload');
        locationDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            locationDropZone.style.backgroundColor = 'rgba(0,0,0,0.4)';
        });

        locationDropZone.addEventListener('dragleave', () => {
            locationDropZone.style.backgroundColor = '';
        });

        locationDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            locationDropZone.style.backgroundColor = '';
            handleLocationFileDrop(e);
        });

        // Functions
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('vnSettings');
                if (savedSettings) {
                    const parsed = JSON.parse(savedSettings);
                    gameState.settings = {...gameState.settings, ...parsed};
                    
                    // Update UI
                    elements.modelSelect.value = gameState.settings.model;
                    
                    // Handle API keys
                    updateApiKeysUI();
                    
                    elements.temperature.value = gameState.settings.temperature;
                    elements.tempValue.textContent = gameState.settings.temperature;
                    elements.maxTokens.value = gameState.settings.maxTokens;
                    elements.romanceMode.checked = gameState.settings.modes.romance;
                    elements.cuteMode.checked = gameState.settings.modes.cuteness;
                    elements.cringeMode.checked = gameState.settings.modes.cringe;
                    elements.storyMode.checked = gameState.settings.modes.story;
                    elements.storyTitle.value = gameState.settings.storyTitle || '';
                    elements.storyDescription.value = gameState.settings.storyDescription || '';
                    
                    // System prompt
                    elements.systemPrompt.value = gameState.settings.systemPrompt || DEFAULT_SYSTEM_PROMPT;
                    
                    // Load characters
                    if (gameState.settings.characters) {
                        gameState.characters = gameState.settings.characters;
                        updateCharacterList();
                    }
                    
                    // Load backgrounds
                    if (gameState.settings.backgrounds) {
                        gameState.backgrounds = gameState.settings.backgrounds;
                        updateLocationList();
                    }
                    
                    // Load user resources
                    if (gameState.settings.userResources) {
                        gameState.userResources = gameState.settings.userResources;
                    }
                    
                    // Load story events
                    if (gameState.settings.storyEvents && gameState.settings.storyEvents.length > 0) {
                        elements.eventsContainer.innerHTML = '';
                        gameState.settings.storyEvents.forEach(event => {
                            const eventInput = document.createElement('div');
                            eventInput.className = 'form-group';
                            eventInput.innerHTML = `<input type="text" class="story-event" value="${event}" placeholder="Событие, которое должно произойти...">`;
                            elements.eventsContainer.appendChild(eventInput);
                        });
                    }
                } else {
                    // First time setup - initialize with default values
                    elements.systemPrompt.value = DEFAULT_SYSTEM_PROMPT;
                }
            } catch (error) {
                console.error('Error loading settings:', error);
                elements.systemPrompt.value = DEFAULT_SYSTEM_PROMPT;
            }
        }

        function saveSettings() {
            try {
                // API keys collection
                const apiKeys = [];
                document.querySelectorAll('.api-key-input').forEach(input => {
                    if (input.value.trim()) {
                        apiKeys.push(input.value.trim());
                    }
                });
                
                gameState.settings.model = elements.modelSelect.value;
                gameState.settings.apiKeys = apiKeys;
                gameState.settings.temperature = parseFloat(elements.temperature.value);
                gameState.settings.maxTokens = parseInt(elements.maxTokens.value);
                gameState.settings.modes.romance = elements.romanceMode.checked;
                gameState.settings.modes.cuteness = elements.cuteMode.checked;
                gameState.settings.modes.cringe = elements.cringeMode.checked;
                gameState.settings.modes.story = elements.storyMode.checked;
                gameState.settings.storyTitle = elements.storyTitle.value;
                gameState.settings.storyDescription = elements.storyDescription.value;
                gameState.settings.systemPrompt = elements.systemPrompt.value;
                
                // Save story events
                gameState.settings.storyEvents = [];
                document.querySelectorAll('.story-event').forEach(input => {
                    if (input.value.trim()) {
                        gameState.settings.storyEvents.push(input.value.trim());
                    }
                });
                
                // Save to localStorage
                gameState.settings.characters = gameState.characters;
                gameState.settings.backgrounds = gameState.backgrounds;
                gameState.settings.userResources = gameState.userResources;
                localStorage.setItem('vnSettings', JSON.stringify(gameState.settings));
            } catch (error) {
                console.error('Error saving settings:', error);
            }
        }

        function updateApiKeysUI() {
            elements.apiKeysContainer.innerHTML = '';
            
            if (!gameState.settings.apiKeys || gameState.settings.apiKeys.length === 0) {
                // Add one empty field if no keys
                addApiKeyField();
                return;
            }
            
            gameState.settings.apiKeys.forEach(key => {
                addApiKeyField(key);
            });
        }

        function addApiKeyField(value = '') {
            const keyItem = document.createElement('div');
            keyItem.className = 'api-key-item';
            keyItem.innerHTML = `
                <input type="text" class="api-key-input" value="${value}" placeholder="sk-or-...">
                <button class="remove-api-key-btn">✕</button>
            `;
            elements.apiKeysContainer.appendChild(keyItem);
            
            // Add remove event listener
            keyItem.querySelector('.remove-api-key-btn').addEventListener('click', () => {
                if (document.querySelectorAll('.api-key-item').length > 1) {
                    keyItem.remove();
                } else {
                    keyItem.querySelector('.api-key-input').value = '';
                }
            });
        }

        async function scanResources() {
            try {
                await scanBackgrounds();
                await scanCharacters();
            } catch (error) {
                console.error('Error scanning resources:', error);
                alert('Ошибка при сканировании ресурсов. Пожалуйста, проверьте консоль для деталей.');
            }
        }

        async function scanBackgrounds() {
            try {
                // Fetch the list of backgrounds
                const response = await fetch('backgrounds/');
                
                if (!response.ok) {
                    throw new Error('Не удалось получить список фонов');
                }
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Extract file links
                const links = Array.from(doc.querySelectorAll('a')).map(a => a.href);
                
                // Filter image files and extract filenames
                const imageFiles = links
                    .filter(link => /\.(jpg|jpeg|png|gif|webp)$/i.test(link))
                    .map(link => {
                        const parts = link.split('/');
                        return parts[parts.length - 1];
                    });
                
                // Add backgrounds
                imageFiles.forEach(file => {
                    const key = file.replace(/\.[^/.]+$/, ""); // Remove file extension
                    const name = key.replace(/([A-Z])/g, ' $1').trim(); // Add spaces before capitals
                    
                    if (!gameState.backgrounds[key]) {
                        gameState.backgrounds[key] = {
                            name: name,
                            description: `Фон: ${name}`,
                            file: file
                        };
                    }
                });
                
                updateLocationList();
                return true;
            } catch (error) {
                console.error('Error scanning backgrounds:', error);
                
                // Fallback: add default background if scan fails
                if (!gameState.backgrounds['ВходВоротаВпионерлагерь']) {
                    gameState.backgrounds['ВходВоротаВпионерлагерь'] = {
                        name: 'Вход в пионерлагерь',
                        description: 'Ворота лагеря с яркой вывеской "Добро пожаловать!"',
                        file: 'ВходВоротаВпионерлагерь.jpg'
                    };
                    updateLocationList();
                }
                
                return false;
            }
        }

        async function scanCharacters() {
            try {
                // Fetch the sprites directory
                const response = await fetch('sprites/');
                
                if (!response.ok) {
                    throw new Error('Не удалось получить список персонажей');
                }
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Extract directory links
                const links = Array.from(doc.querySelectorAll('a'))
                    .filter(a => a.href.endsWith('/') && !a.href.endsWith('../'))
                    .map(a => {
                        const href = a.href;
                        return href.substring(href.indexOf('sprites/') + 8, href.length - 1);
                    });
                
                // Scan each character directory
                for (const charName of links) {
                    try {
                        // Only process if it's not already in our list
                        if (!gameState.characters[charName]) {
                            const charResponse = await fetch(`sprites/${charName}/`);
                            const charHtml = await charResponse.text();
                            const charDoc = parser.parseFromString(charHtml, 'text/html');
                            
                            // Extract sprite files
                            const spriteLinks = Array.from(charDoc.querySelectorAll('a'))
                                .filter(a => /\.(png|jpg|jpeg|gif|webp)$/i.test(a.href))
                                .map(a => {
                                    const href = a.href;
                                    return href.substring(href.lastIndexOf('/') + 1);
                                });
                            
                            // Add character
                            gameState.characters[charName] = {
                                name: charName,
                                description: `${charName} - персонаж визуальной новеллы`,
                                sprites: spriteLinks
                            };
                        }
                    } catch (charError) {
                        console.error(`Error scanning character ${charName}:`, charError);
                    }
                }
                
                updateCharacterList();
                return true;
            } catch (error) {
                console.error('Error scanning characters:', error);
                
                // Fallback: add default character if scan fails
                if (!gameState.characters.Алиса) {
                    gameState.characters.Алиса = {
                        name: 'Алиса',
                        description: 'Активная и энергичная девушка с рыжими волосами. Спортивная, немного вспыльчивая, но добрая.',
                        sprites: ['normal.png', 'happy.png', 'angry.png', 'sad.png', 'surprised.png']
                    };
                    updateCharacterList();
                }
                
                return false;
            }
        }

        function updateCharacterList() {
            elements.characterList.innerHTML = '';
            
            Object.values(gameState.characters).forEach(character => {
                const item = document.createElement('div');
                item.className = 'resource-item';
                item.innerHTML = `
                    <div class="resource-item-name">${character.name}</div>
                    <div class="resource-controls">
                        <button class="edit-btn" data-name="${character.name}">✏️</button>
                        <button class="delete-btn" data-name="${character.name}">🗑️</button>
                    </div>
                `;
                elements.characterList.appendChild(item);
            });
            
            // Add user-uploaded characters
            Object.values(gameState.userResources.characters).forEach(character => {
                const item = document.createElement('div');
                item.className = 'resource-item';
                item.innerHTML = `
                    <div class="resource-item-name">${character.name} (загруженный)</div>
                    <div class="resource-controls">
                        <button class="edit-btn" data-name="${character.name}" data-user="true">✏️</button>
                        <button class="delete-btn" data-name="${character.name}" data-user="true">🗑️</button>
                    </div>
                `;
                elements.characterList.appendChild(item);
            });
            
            // Add event listeners to edit and delete buttons
            document.querySelectorAll('#character-list .edit-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (btn.dataset.user === 'true') {
                        openCharacterModal(btn.dataset.name, true);
                    } else {
                        openCharacterModal(btn.dataset.name);
                    }
                });
            });
            
            document.querySelectorAll('#character-list .delete-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const isUserResource = btn.dataset.user === 'true';
                    if (confirm(`Удалить персонажа ${btn.dataset.name}?`)) {
                        if (isUserResource) {
                            delete gameState.userResources.characters[btn.dataset.name];
                        } else {
                            delete gameState.characters[btn.dataset.name];
                        }
                        updateCharacterList();
                    }
                });
            });
        }

        function updateLocationList() {
            elements.locationList.innerHTML = '';
            
            Object.values(gameState.backgrounds).forEach(location => {
                const item = document.createElement('div');
                item.className = 'resource-item';
                item.innerHTML = `
                    <div class="resource-item-name">${location.name}</div>
                    <div class="resource-controls">
                        <button class="edit-btn" data-name="${location.name}">✏️</button>
                        <button class="delete-btn" data-name="${location.name}">🗑️</button>
                    </div>
                `;
                elements.locationList.appendChild(item);
            });
            
            // Add user-uploaded backgrounds
            Object.values(gameState.userResources.backgrounds).forEach(location => {
                const item = document.createElement('div');
                item.className = 'resource-item';
                item.innerHTML = `
                    <div class="resource-item-name">${location.name} (загруженный)</div>
                    <div class="resource-controls">
                        <button class="edit-btn" data-name="${location.name}" data-user="true">✏️</button>
                        <button class="delete-btn" data-name="${location.name}" data-user="true">🗑️</button>
                    </div>
                `;
                elements.locationList.appendChild(item);
            });
            
            // Add event listeners to edit and delete buttons
            document.querySelectorAll('#location-list .edit-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (btn.dataset.user === 'true') {
                        openLocationModal(btn.dataset.name, true);
                    } else {
                        openLocationModal(btn.dataset.name);
                    }
                });
            });
            
            document.querySelectorAll('#location-list .delete-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const isUserResource = btn.dataset.user === 'true';
                    if (confirm(`Удалить локацию ${btn.dataset.name}?`)) {
                        if (isUserResource) {
                            delete gameState.userResources.backgrounds[btn.dataset.name];
                        } else {
                            const locationKey = Object.keys(gameState.backgrounds).find(
                                key => gameState.backgrounds[key].name === btn.dataset.name
                            );
                            if (locationKey) {
                                delete gameState.backgrounds[locationKey];
                            }
                        }
                        updateLocationList();
                    }
                });
            });
        }

        function openCharacterModal(characterName = null, isUserResource = false) {
            const modal = elements.characterModal;
            const nameInput = document.getElementById('character-name');
            const descriptionInput = document.getElementById('character-description');
            const preview = document.getElementById('character-preview');
            const spritesContainer = document.getElementById('character-sprites');
            
            // Clear previous data
            preview.style.backgroundImage = '';
            spritesContainer.innerHTML = '';
            
            if (characterName) {
                let character;
                
                if (isUserResource) {
                    character = gameState.userResources.characters[characterName];
                } else {
                    character = gameState.characters[characterName];
                }
                
                if (character) {
                    nameInput.value = character.name;
                    descriptionInput.value = character.description;
                    
                    // Handle uploaded character
                    if (isUserResource && character.image) {
                        preview.style.backgroundImage = `url(${character.image})`;
                    }
                    
                    // Display sprites
                    if (!isUserResource && character.sprites && character.sprites.length > 0) {
                        character.sprites.forEach(sprite => {
                            const spriteDiv = document.createElement('div');
                            spriteDiv.className = 'sprite-item';
                            spriteDiv.style.backgroundImage = `url('sprites/${characterName}/${sprite}')`;
                            
                            const spriteName = document.createElement('div');
                            spriteName.className = 'sprite-item-name';
                            spriteName.textContent = sprite.replace('.png', '');
                            
                            spriteDiv.appendChild(spriteName);
                            spritesContainer.appendChild(spriteDiv);
                        });
                    } else if (isUserResource && character.emotions) {
                        character.emotions.forEach(emotion => {
                            const spriteDiv = document.createElement('div');
                            spriteDiv.className = 'sprite-item';
                            spriteDiv.style.backgroundImage = `url(${character.image})`;
                            
                            const spriteName = document.createElement('div');
                            spriteName.className = 'sprite-item-name';
                            spriteName.textContent = emotion;
                            
                            spriteDiv.appendChild(spriteName);
                            spritesContainer.appendChild(spriteDiv);
                        });
                    }
                    
                    // Store original data for update
                    nameInput.dataset.originalName = characterName;
                    nameInput.dataset.isUser = isUserResource ? 'true' : 'false';
                } else {
                    console.error('Character not found:', characterName);
                    return;
                }
            } else {
                // New character
                nameInput.value = '';
                descriptionInput.value = '';
                nameInput.dataset.originalName = '';
                nameInput.dataset.isUser = 'true'; // New characters are user resources
            }
            
            modal.style.display = 'flex';
        }

        function openLocationModal(locationName = null, isUserResource = false) {
            const modal = elements.locationModal;
            const nameInput = document.getElementById('location-name');
            const descriptionInput = document.getElementById('location-description');
            const preview = document.getElementById('location-preview');
            
            if (locationName) {
                let location;
                
                if (isUserResource) {
                    location = gameState.userResources.backgrounds[locationName];
                    
                    if (location) {
                        nameInput.value = location.name;
                        descriptionInput.value = location.description;
                        preview.style.backgroundImage = `url(${location.image})`;
                        
                        // Store original data for update
                        nameInput.dataset.originalName = locationName;
                        nameInput.dataset.isUser = 'true';
                    }
                } else {
                    const locationKey = Object.keys(gameState.backgrounds).find(
                        key => gameState.backgrounds[key].name === locationName
                    );
                    
                    if (locationKey && gameState.backgrounds[locationKey]) {
                        const location = gameState.backgrounds[locationKey];
                        nameInput.value = location.name;
                        descriptionInput.value = location.description;
                        preview.style.backgroundImage = `url('backgrounds/${location.file}')`;
                        
                        // Store original data for update
                        nameInput.dataset.originalKey = locationKey;
                        nameInput.dataset.isUser = 'false';
                    }
                }
            } else {
                // New location
                nameInput.value = '';
                descriptionInput.value = '';
                preview.style.backgroundImage = '';
                nameInput.dataset.originalKey = '';
                nameInput.dataset.originalName = '';
                nameInput.dataset.isUser = 'true'; // New locations are user resources
            }
            
            modal.style.display = 'flex';
        }

        function handleCharacterFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                const file = files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const characterPreview = document.getElementById('character-preview');
                    characterPreview.style.backgroundImage = `url(${e.target.result})`;
                    characterPreview.dataset.image = e.target.result;
                };
                
                reader.readAsDataURL(file);
            }
        }

        function handleCharacterFileDrop(event) {
            event.preventDefault();
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const characterPreview = document.getElementById('character-preview');
                    characterPreview.style.backgroundImage = `url(${e.target.result})`;
                    characterPreview.dataset.image = e.target.result;
                };
                
                reader.readAsDataURL(file);
            }
        }

        function handleLocationFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                const file = files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const locationPreview = document.getElementById('location-preview');
                    locationPreview.style.backgroundImage = `url(${e.target.result})`;
                    locationPreview.dataset.image = e.target.result;
                };
                
                reader.readAsDataURL(file);
            }
        }

        function handleLocationFileDrop(event) {
            event.preventDefault();
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const locationPreview = document.getElementById('location-preview');
                    locationPreview.style.backgroundImage = `url(${e.target.result})`;
                    locationPreview.dataset.image = e.target.result;
                };
                
                reader.readAsDataURL(file);
            }
        }

        function saveCharacter() {
            const nameInput = document.getElementById('character-name');
            const descriptionInput = document.getElementById('character-description');
            const preview = document.getElementById('character-preview');
            const originalName = nameInput.dataset.originalName;
            const isUserResource = nameInput.dataset.isUser === 'true';
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Имя персонажа не может быть пустым');
                return;
            }
            
            // Handle user resource
            if (isUserResource) {
                // Remove old entry if renamed
                if (originalName && originalName !== newName) {
                    delete gameState.userResources.characters[originalName];
                }
                
                // Check if we have an image
                if (!preview.dataset.image && !originalName) {
                    alert('Пожалуйста, загрузите изображение персонажа');
                    return;
                }
                
                // Create or update character
                gameState.userResources.characters[newName] = {
                    name: newName,
                    description: descriptionInput.value.trim(),
                    image: preview.dataset.image || gameState.userResources.characters[originalName]?.image,
                    emotions: ['normal', 'happy', 'sad', 'angry', 'surprised'] // Default emotions
                };
            } else {
                // Renaming system character
                if (originalName && originalName !== newName) {
                    delete gameState.characters[originalName];
                }
                
                // Update regular character
                gameState.characters[newName] = {
                    name: newName,
                    description: descriptionInput.value.trim(),
                    sprites: gameState.characters[originalName]?.sprites || []
                };
            }
            
            updateCharacterList();
            elements.characterModal.style.display = 'none';
        }

        function saveLocation() {
            const nameInput = document.getElementById('location-name');
            const descriptionInput = document.getElementById('location-description');
            const preview = document.getElementById('location-preview');
            const isUserResource = nameInput.dataset.isUser === 'true';
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Название локации не может быть пустым');
                return;
            }
            
            if (isUserResource) {
                const originalName = nameInput.dataset.originalName;
                
                // Remove old entry if renamed
                if (originalName && originalName !== newName) {
                    delete gameState.userResources.backgrounds[originalName];
                }
                
                // Check if we have an image
                if (!preview.dataset.image && !originalName) {
                    alert('Пожалуйста, загрузите изображение локации');
                    return;
                }
                
                // Create or update location
                gameState.userResources.backgrounds[newName] = {
                    name: newName,
                    description: descriptionInput.value.trim(),
                    image: preview.dataset.image || gameState.userResources.backgrounds[originalName]?.image
                };
            } else {
                const originalKey = nameInput.dataset.originalKey;
                
                // Generate a key from the name
                const newKey = newName.replace(/\s+/g, '');
                
                // If renaming, remove old entry
                if (originalKey && originalKey !== newKey) {
                    delete gameState.backgrounds[originalKey];
                }
                
                // Create or update location
                gameState.backgrounds[newKey] = {
                    name: newName,
                    description: descriptionInput.value.trim(),
                    file: gameState.backgrounds[originalKey]?.file || `${newKey}.jpg`
                };
            }
            
            updateLocationList();
            elements.locationModal.style.display = 'none';
        }

        function startGame() {
            elements.settings.style.display = 'none';
            elements.game.style.display = 'block';
            
            // Set initial background
            setBackground('ВходВоротаВпионерлагерь');
            
            // Initialize game context
            initializeGameContext();
        }

        function setBackground(backgroundKey, isUserResource = false) {
            if (isUserResource && gameState.userResources.backgrounds[backgroundKey]) {
                elements.background.style.backgroundImage = `url(${gameState.userResources.backgrounds[backgroundKey].image})`;
                gameState.currentBackground = backgroundKey;
            } else if (gameState.backgrounds[backgroundKey]) {
                const bg = gameState.backgrounds[backgroundKey];
                elements.background.style.backgroundImage = `url('backgrounds/${bg.file}')`;
                gameState.currentBackground = backgroundKey;
            }
        }

        function showCharacter(characterName, emotion = 'normal', position = 'center') {
            let isUserResource = false;
            let character;
            
            // Check if this is a user resource
            if (gameState.userResources.characters[characterName]) {
                character = gameState.userResources.characters[characterName];
                isUserResource = true;
            } else if (gameState.characters[characterName]) {
                character = gameState.characters[characterName];
            } else {
                console.error('Character not found:', characterName);
                return;
            }
            
            // Check if character is already on screen
            let characterElement = document.querySelector(`.character[data-name="${characterName}"]`);
            
            if (!characterElement) {
                // Create new character element
                characterElement = document.createElement('div');
                characterElement.className = 'character';
                characterElement.dataset.name = characterName;
                elements.characters.appendChild(characterElement);
            }
            
            // Set position
            let posX = '50%';
            if (position === 'left') posX = '25%';
            if (position === 'right') posX = '75%';
            
            characterElement.style.left = posX;
            characterElement.style.transform = 'translateX(-50%)';
            
            // Set sprite based on whether it's user resource or not
            if (isUserResource) {
                characterElement.style.backgroundImage = `url(${character.image})`;
            } else {
                let spriteFile = 'normal.png'; // Default
                
                if (character.sprites && character.sprites.includes(`${emotion}.png`)) {
                    spriteFile = `${emotion}.png`;
                } else if (character.sprites && character.sprites.length > 0) {
                    spriteFile = character.sprites[0];
                }
                
                characterElement.style.backgroundImage = `url('sprites/${characterName}/${spriteFile}')`;
            }
            
            characterElement.style.backgroundSize = 'contain';
            characterElement.style.backgroundPosition = 'bottom center';
            characterElement.style.backgroundRepeat = 'no-repeat';
            
            // Make sure character is visible
            characterElement.style.opacity = '1';
            
            // Add to active characters
            gameState.activeCharacters[characterName] = {
                emotion: emotion,
                position: position,
                isUserResource: isUserResource
            };
        }

        function hideCharacter(characterName) {
            const characterElement = document.querySelector(`.character[data-name="${characterName}"]`);
            if (characterElement) {
                characterElement.style.opacity = '0';
                setTimeout(() => {
                    characterElement.remove();
                }, 500);
            }
            
            delete gameState.activeCharacters[characterName];
        }

        function typeText(text) {
            return new Promise(resolve => {
                elements.dialogueText.textContent = ''; // Clear previous text
                
                // Add each character with a delay
                let i = 0;
                const typingSpeed = 30; // ms per character
                
                function typeChar() {
                    if (i < text.length) {
                        elements.dialogueText.textContent += text.charAt(i);
                        i++;
                        setTimeout(typeChar, typingSpeed);
                    } else {
                        resolve();
                    }
                }
                
                typeChar();
            });
        }

        function showChoices(choices) {
            elements.choices.innerHTML = '';
            
            choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.textContent = choice;
                button.addEventListener('click', () => {
                    selectChoice(choice);
                });
                elements.choices.appendChild(button);
            });
        }

        function selectChoice(choice) {
            elements.choices.innerHTML = '';
            sendMessage(choice);
        }

        function initializeGameContext() {
            // Build the system prompt
            const systemPrompt = generateSystemPrompt();
            
            // Start the conversation
            sendSystemMessage(systemPrompt);
        }

        function generateSystemPrompt() {
            // Create the character list for the system prompt
            let charactersListText = '';
            
            // Add regular characters
            Object.values(gameState.characters).forEach(character => {
                charactersListText += `${character.name}: ${character.description}\n`;
                charactersListText += `Доступные эмоции: ${character.sprites ? character.sprites.map(s => s.replace('.png', '')).join(', ') : 'normal'}\n\n`;
            });
            
            // Add user-uploaded characters
            Object.values(gameState.userResources.characters).forEach(character => {
                charactersListText += `${character.name}: ${character.description}\n`;
                charactersListText += `Доступные эмоции: ${character.emotions ? character.emotions.join(', ') : 'normal'}\n\n`;
            });
            
            // Create the backgrounds list
            let backgroundsListText = '';
            
            // Add regular backgrounds
            Object.values(gameState.backgrounds).forEach(bg => {
                backgroundsListText += `${bg.name}: ${bg.description}\n`;
            });
            
            // Add user-uploaded backgrounds
            Object.values(gameState.userResources.backgrounds).forEach(bg => {
                backgroundsListText += `${bg.name}: ${bg.description}\n`;
            });
            
            // Build mode-specific instructions
            let modeInstructions = '';
            
            if (gameState.settings.modes.romance) {
                modeInstructions += 'Включай в сюжет романтические линии и возможность отношений между персонажами. ';
            }
            
            if (gameState.settings.modes.cuteness) {
                modeInstructions += 'Делай историю милой и позитивной, с акцентом на приятные моменты и дружеские отношения. ';
            }
            
            if (gameState.settings.modes.cringe) {
                modeInstructions += 'Добавляй неловкие и забавные ситуации, которые могут вызвать смущение у персонажей. ';
            }
            
            if (gameState.settings.modes.story) {
                modeInstructions += 'Следуй структуре истории с началом, развитием и кульминацией. История должна длиться 7 игровых дней. ';
                
                if (gameState.settings.storyEvents.length > 0) {
                    modeInstructions += 'Обязательно включи следующие события в повествование: ' + gameState.settings.storyEvents.join(', ') + '. ';
                }
            }
            
            // Start with user-defined system prompt
            let customPrompt = gameState.settings.systemPrompt;
            
            // Replace placeholders
            customPrompt = customPrompt.replace('{{CHARACTERS_LIST}}', charactersListText);
            customPrompt = customPrompt.replace('{{BACKGROUNDS_LIST}}', backgroundsListText);
            customPrompt = customPrompt.replace('{{STORY_TITLE}}', gameState.settings.storyTitle || 'Летние приключения');
            customPrompt = customPrompt.replace('{{STORY_DESCRIPTION}}', gameState.settings.storyDescription || 'История о летнем отдыхе в пионерском лагере');
            customPrompt = customPrompt.replace('{{CURRENT_DAY}}', gameState.gameDay.toString());
            customPrompt = customPrompt.replace('{{STORY_MODE_ENABLED}}', gameState.settings.modes.story ? '(из 7)' : '');
            customPrompt = customPrompt.replace('{{MODE_INSTRUCTIONS}}', modeInstructions);
            customPrompt = customPrompt.replace('{{COMPRESSED_HISTORY}}', gameState.compressedHistory || 'История только начинается.');
            
            return customPrompt;
        }

        async function sendSystemMessage(message) {
            try {
                elements.loading.style.display = 'flex';
                
                const response = await callLLM(message, true);
                
                if (response) {
                    processLLMResponse(response);
                    gameState.context.push({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                }
                
                elements.loading.style.display = 'none';
            } catch (error) {
                console.error('Error in system message:', error);
                elements.loading.style.display = 'none';
                alert('Произошла ошибка при инициализации истории. Пожалуйста, проверьте API ключ и настройки.');
            }
        }

        async function sendMessage(message) {
            if (gameState.waitingForResponse) return;
            
            try {
                gameState.waitingForResponse = true;
                elements.loading.style.display = 'flex';
                
                // Add user message to context
                gameState.context.push({
                    role: 'user',
                    content: message
                });
                
                // Add to focus window for context management
                manageFocusWindow({
                    role: 'user',
                    content: message
                });
                
                const response = await callLLM();
                
                if (response) {
                    processLLMResponse(response);
                    
                    // Store the last response for potential regeneration
                    gameState.lastResponse = response;
                    
                    // Add to context and focus window
                    gameState.context.push({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                    
                    manageFocusWindow({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                }
                
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
            } catch (error) {
                console.error('Error in user message:', error);
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
                alert('Произошла ошибка при обработке сообщения.');
            }
        }

        async function sendUserInput() {
            const input = elements.userInput.value.trim();
            if (!input) return;
            
            elements.userInput.value = '';
            sendMessage(input);
        }

        async function regenerateResponse() {
            if (gameState.waitingForResponse) return;
            
            try {
                gameState.waitingForResponse = true;
                elements.loading.style.display = 'flex';
                
                // Remove the last assistant message from context
                if (gameState.context.length > 0 && gameState.context[gameState.context.length - 1].role === 'assistant') {
                    gameState.context.pop();
                }
                
                // Remove from focus window as well
                if (gameState.focusWindow.length > 0 && gameState.focusWindow[gameState.focusWindow.length - 1].role === 'assistant') {
                    gameState.focusWindow.pop();
                }
                
                const response = await callLLM();
                
                if (response) {
                    processLLMResponse(response);
                    
                    // Update the last response
                    gameState.lastResponse = response;
                    
                    // Add to context and focus window
                    gameState.context.push({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                    
                    manageFocusWindow({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                }
                
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
            } catch (error) {
                console.error('Error in regeneration:', error);
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
                alert('Произошла ошибка при перегенерации ответа.');
            }
        }

        async function sendDirectRequest() {
            if (gameState.waitingForResponse) return;
            
            const input = elements.directRequest.value.trim();
            if (!input) return;
            
            try {
                gameState.waitingForResponse = true;
                elements.loading.style.display = 'flex';
                elements.menuDropdown.style.display = 'none';
                
                // Add a special system message to guide the direct request
                const directSystemPrompt = `
Ты являешься искусственным интеллектом, управляющим интерактивной визуальной новеллой.
Игрок отправил тебе прямой запрос: "${input}"

Это специальный режим, в котором ты помогаешь игроку решить проблему или изменить ход истории.
Ответь в обычном JSON формате, как если бы это был следующий ход в истории.

Сделай свой ответ релевантным текущей ситуации в игре и постарайся учесть запрос игрока.
                `;
                
                // Create a temporary context for this request
                const tempContext = [
                    { role: 'system', content: directSystemPrompt },
                    ...gameState.context.slice(-5) // Include last 5 messages for context
                ];
                
                const response = await callLLM(undefined, false, tempContext);
                
                if (response) {
                    processLLMResponse(response);
                    
                    // Add this exchange to the regular context
                    gameState.context.push({
                        role: 'user',
                        content: `[Прямой запрос]: ${input}`
                    });
                    
                    gameState.context.push({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                    
                    // Manage focus window
                    manageFocusWindow({
                        role: 'user',
                        content: `[Прямой запрос]: ${input}`
                    });
                    
                    manageFocusWindow({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                }
                
                elements.directRequest.value = '';
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
            } catch (error) {
                console.error('Error in direct request:', error);
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
                alert('Произошла ошибка при обработке прямого запроса.');
            }
        }

        function manageFocusWindow(message) {
            // Add message to focus window
            gameState.focusWindow.push(message);
            
            // Keep only the last 5 messages in the focus window
            if (gameState.focusWindow.length > 5) {
                // Take the older messages and compress them
                const oldMessages = gameState.focusWindow.splice(0, gameState.focusWindow.length - 5);
                
                // In a real implementation, we would send these to be compressed
                // For now, we'll just create a simple summary
                const summary = oldMessages.map(m => {
                    if (m.role === 'user') {
                        return `Игрок: ${m.content}`;
                    } else if (m.role === 'assistant') {
                        try {
                            const parsed = JSON.parse(m.content);
                            return parsed.messages.map(msg => {
                                return `${msg.speaker}: ${msg.text}`;
                            }).join(' ');
                        } catch (e) {
                            return `Ассистент: ${m.content}`;
                        }
                    }
                    return '';
                }).join('\n');
                
                // Append to compressed history
                if (gameState.compressedHistory) {
                    gameState.compressedHistory += '\n\n';
                }
                gameState.compressedHistory += summary;
                
                // Check if we need to compress further
                if (gameState.compressedHistory.length > 10000) {
                    // In a real implementation, we would super-compress the history
                    // For now, we'll just keep the most recent part
                    gameState.compressedHistory = gameState.compressedHistory.slice(-5000);
                    gameState.compressedHistory = "Сжатая история предыдущих событий:\n" + gameState.compressedHistory;
                }
            }
        }

        async function callLLM(systemPrompt = undefined, isSystemMessage = false, customContext = null) {
            // Get all API keys
            const apiKeys = gameState.settings.apiKeys.filter(key => key.trim());
            
            if (apiKeys.length === 0) {
                alert('Пожалуйста, введите хотя бы один API ключ OpenRouter в настройках.');
                return null;
            }
            
            // Rotate through API keys
            if (gameState.settings.currentKeyIndex >= apiKeys.length) {
                gameState.settings.currentKeyIndex = 0;
            }
            
            const apiKey = apiKeys[gameState.settings.currentKeyIndex];
            
            // Move to next key for next call
            gameState.settings.currentKeyIndex = (gameState.settings.currentKeyIndex + 1) % apiKeys.length;
            
            try {
                let messages = [];
                
                if (customContext) {
                    // Use custom context if provided (for direct requests)
                    messages = customContext;
                } else {
                    // For system initialization
                    if (isSystemMessage) {
                        messages = [
                            { role: 'system', content: systemPrompt }
                        ];
                    } else {
                        // For regular messages, include compressed history and focus window
                        let contextPrompt = generateSystemPrompt();
                        
                        messages = [
                            { role: 'system', content: contextPrompt },
                            ...gameState.focusWindow // Include only the focus window messages
                        ];
                    }
                }
                
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: gameState.settings.model,
                        messages: messages,
                        temperature: gameState.settings.temperature,
                        max_tokens: gameState.settings.maxTokens
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${JSON.stringify(errorData)}`);
                }
                
                const data = await response.json();
                let content = data.choices[0].message.content;
                
                try {
                    // Try to parse as JSON
                    return JSON.parse(content);
                } catch (e) {
                    // If it's not valid JSON, try to extract JSON part
                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            return JSON.parse(jsonMatch[0]);
                        } catch (e2) {
                            console.error('Failed to parse JSON from response:', content);
                            throw new Error('Получен некорректный формат ответа от LLM.');
                        }
                    } else {
                        console.error('No JSON found in response:', content);
                        throw new Error('Получен некорректный формат ответа от LLM.');
                    }
                }
            } catch (error) {
                console.error('API Error:', error);
                throw error;
            }
        }

        async function processLLMResponse(response) {
            try {
                if (!response.messages || !Array.isArray(response.messages)) {
                    throw new Error('Некорректный формат ответа от LLM');
                }
                
                // Process each message
                for (const message of response.messages) {
                    // Set background if specified
                    if (message.background) {
                        // Check if it's a user-uploaded background
                        if (gameState.userResources.backgrounds[message.background]) {
                            setBackground(message.background, true);
                        } else {
                            // Find the background key by name
                            const backgroundKey = Object.keys(gameState.backgrounds).find(
                                key => gameState.backgrounds[key].name === message.background
                            ) || message.background;
                            
                            setBackground(backgroundKey);
                        }
                    }
                    
                    // Update speaker name
                    elements.speaker.textContent = message.speaker === 'narrator' ? '' : message.speaker;
                    
                    // Show character if it's a character speaking
                    if (message.speaker && message.speaker !== 'narrator') {
                        const position = message.position || 'center';
                        const emotion = message.emotion || 'normal';
                        showCharacter(message.speaker, emotion, position);
                    }
                    
                    // Display text with typewriter effect
                    await typeText(message.text);
                    
                    // Show choices if any
                    if (message.choices && message.choices.length > 0) {
                        showChoices(message.choices);
                    }
                    
                    // Wait for user interaction if choices are shown
                    if (message.choices && message.choices.length > 0) {
                        // Don't continue to next message if choices are presented
                        break;
                    }
                    
                    // Add a small delay between messages for readability
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Check if there's a resource request
                if (response.resource_request) {
                    console.log('Resource request detected:', response.resource_request);
                    // In a real implementation, we would handle the resource request
                    // e.g., prompt the user to upload a new character or background
                }
            } catch (error) {
                console.error('Error processing LLM response:', error);
                alert('Произошла ошибка при обработке ответа LLM.');
            }
        }
    </script>
</body>
</html>

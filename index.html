<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Визуальная Новелла</title>
    <style>
        :root {
            --primary-color: #6d4aff;
            --secondary-color: #ff6e9f;
            --dark-color: #2d2b55;
            --light-color: #f8f8f2;
            --shadow-color: rgba(0,0,0,0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: var(--light-color);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Disclaimer Screen */
        #disclaimer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 2rem;
        }

        .disclaimer-content {
            background: var(--dark-color);
            border-radius: 15px;
            padding: 2rem;
            max-width: 600px;
            box-shadow: 0 10px 25px var(--shadow-color);
            text-align: center;
            animation: fadeIn 0.5s ease-out;
        }

        .disclaimer-content h2 {
            color: var(--secondary-color);
            margin-bottom: 1.5rem;
            font-size: 2rem;
        }

        .disclaimer-content p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        /* Settings Screen */
        #settings {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: none;
            z-index: 900;
            overflow-y: auto;
            padding: 2rem;
        }

        .settings-container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(45, 43, 85, 0.8);
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 25px var(--shadow-color);
        }

        .settings-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .settings-header h2 {
            color: var(--secondary-color);
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .settings-tabs {
            display: flex;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 2rem;
        }

        .tab-btn {
            padding: 0.8rem 1.5rem;
            background: none;
            border: none;
            color: var(--light-color);
            font-size: 1rem;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.3s, border-bottom 0.3s;
            border-bottom: 3px solid transparent;
        }

        .tab-btn.active {
            opacity: 1;
            border-bottom: 3px solid var(--secondary-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.8rem;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            color: var(--light-color);
            font-size: 1rem;
        }

        .form-group input[type="range"] {
            width: 100%;
            margin-top: 0.5rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            margin-right: 0.5rem;
        }

        /* Game Screen */
        #game {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            overflow: hidden;
        }

        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: opacity 1s ease;
        }

        #characters {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .character {
            position: absolute;
            bottom: 20%;
            height: 70%;
            transition: all 0.5s ease-out;
            transform-origin: bottom center;
        }

        #dialogue-box {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 900px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 100;
        }

        #speaker {
            color: var(--secondary-color);
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        #dialogue-text {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 1rem;
            min-height: 3rem;
        }

        #choices {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            margin-top: 1rem;
        }

        .choice-btn {
            background: rgba(109, 74, 255, 0.2);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 0.7rem 1.2rem;
            color: var(--light-color);
            cursor: pointer;
            transition: all 0.3s;
            flex-grow: 1;
        }

        .choice-btn:hover {
            background: rgba(109, 74, 255, 0.4);
        }

        #user-input-container {
            display: flex;
            margin-top: 1rem;
        }

        #user-input {
            flex-grow: 1;
            padding: 0.8rem;
            border-radius: 5px 0 0 5px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            color: var(--light-color);
            font-size: 1rem;
        }

        #send-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 0 5px 5px 0;
            padding: 0.8rem 1.5rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        #send-btn:hover {
            background: #5536e0;
        }

        #regenerate-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 110, 159, 0.2);
            border: 1px solid var(--secondary-color);
            color: var(--light-color);
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        #regenerate-btn:hover {
            background: rgba(255, 110, 159, 0.4);
        }

        /* Menu */
        #menu-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 200;
            transition: background 0.3s;
        }

        #menu-button:hover {
            background: rgba(0,0,0,0.8);
        }

        #menu-dropdown {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            width: 300px;
            padding: 1rem;
            z-index: 300;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            display: none;
        }

        #direct-request {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 5px;
            color: var(--light-color);
            padding: 0.8rem;
            resize: none;
            margin-bottom: 0.8rem;
        }

        #send-direct-btn {
            width: 100%;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.7rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        /* Loading indicator */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: var(--secondary-color);
            animation: spin 1s ease-in-out infinite;
        }

        /* Buttons */
        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
        }

        .btn:hover {
            background: #5536e0;
        }

        .btn-secondary {
            background: var(--secondary-color);
        }

        .btn-secondary:hover {
            background: #e84e8a;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Character and resource management */
        .resource-list {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .resource-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .resource-item:last-child {
            border-bottom: none;
        }

        .resource-item-name {
            font-weight: 600;
        }

        .resource-controls {
            display: flex;
            gap: 0.5rem;
        }

        .edit-btn, .delete-btn {
            background: none;
            border: none;
            color: var(--light-color);
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.3s;
        }

        .edit-btn:hover, .delete-btn:hover {
            opacity: 1;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1200;
            display: none;
        }

        .modal-content {
            background: var(--dark-color);
            border-radius: 15px;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-header h3 {
            color: var(--secondary-color);
        }

        .close-modal {
            background: none;
            border: none;
            color: var(--light-color);
            font-size: 1.5rem;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Disclaimer Screen -->
    <div id="disclaimer">
        <div class="disclaimer-content">
            <h2>Пользовательское соглашение</h2>
            <p>Добро пожаловать в LLM Визуальную Новеллу!</p>
            <p>Разработчик этого приложения не является профессиональным программистом. Большая часть кода была написана с помощью искусственного интеллекта Claude 3.7 от Anthropic.</p>
            <p>Разработчик не несёт ответственности за содержание, генерируемое LLM, возможные технические проблемы или любые другие последствия использования данного приложения.</p>
            <p>Все персонажи в игре старше 21 года. При добавлении собственных персонажей вы обязуетесь использовать изображения только совершеннолетних персонажей.</p>
            <p>Используя это приложение, вы подтверждаете, что не будете использовать его для создания или распространения незаконного или неприемлемого контента.</p>
            <p>Это некоммерческий проект, созданный исключительно в развлекательных и образовательных целях.</p>
            <button class="btn btn-secondary" id="accept-btn">Затерпеть</button>
        </div>
    </div>

    <!-- Settings Screen -->
    <div id="settings">
        <div class="settings-container">
            <div class="settings-header">
                <h2>Настройки новеллы</h2>
                <p>Настройте параметры игры перед началом</p>
            </div>
            
            <div class="settings-tabs">
                <button class="tab-btn active" data-tab="general">Основные</button>
                <button class="tab-btn" data-tab="characters">Персонажи</button>
                <button class="tab-btn" data-tab="locations">Локации</button>
                <button class="tab-btn" data-tab="story">Сюжет</button>
            </div>
            
            <div class="tab-content active" id="general-tab">
                <div class="form-group">
                    <label for="model-select">Модель LLM (в формате OpenRouter)</label>
                    <input type="text" id="model-select" value="google/gemini-2.0-flash-thinking-exp:free">
                </div>
                
                <div class="form-group">
                    <label for="api-key">API Ключ OpenRouter</label>
                    <input type="text" id="api-key" placeholder="sk-or-...">
                </div>
                
                <div class="form-group">
                    <label for="temperature">Креативность (температура): <span id="temp-value">0.2</span></label>
                    <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.2">
                </div>
                
                <div class="form-group">
                    <label for="max-tokens">Максимальное количество токенов в ответе</label>
                    <input type="number" id="max-tokens" value="30000" min="1000" max="100000">
                </div>
                
                <div class="form-group">
                    <label>Режимы игры</label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="romance-mode">
                        <label for="romance-mode">Романтика</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="cute-mode">
                        <label for="cute-mode">Милота</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="cringe-mode">
                        <label for="cringe-mode">Кринжовый режим</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="story-mode">
                        <label for="story-mode">Сюжетный режим (7 дней)</label>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="characters-tab">
                <div class="resource-list" id="character-list">
                    <!-- Characters will be populated here -->
                </div>
                
                <button class="btn" id="add-character-btn">Добавить персонажа</button>
            </div>
            
            <div class="tab-content" id="locations-tab">
                <div class="resource-list" id="location-list">
                    <!-- Locations will be populated here -->
                </div>
                
                <button class="btn" id="add-location-btn">Добавить локацию</button>
            </div>
            
            <div class="tab-content" id="story-tab">
                <div class="form-group">
                    <label for="story-title">Название истории</label>
                    <input type="text" id="story-title" placeholder="Летний лагерь">
                </div>
                
                <div class="form-group">
                    <label for="story-description">Описание сюжета</label>
                    <textarea id="story-description" rows="4" placeholder="Опишите основную идею сюжета..."></textarea>
                </div>
                
                <div class="form-group">
                    <label>Ключевые события (для сюжетного режима)</label>
                    <div id="events-container">
                        <div class="form-group">
                            <input type="text" class="story-event" placeholder="Событие, которое должно произойти...">
                        </div>
                    </div>
                    <button class="btn" id="add-event-btn">Добавить событие</button>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 2rem;">
                <button class="btn btn-secondary" id="start-game-btn">Начать игру</button>
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game">
        <div id="background"></div>
        <div id="characters"></div>
        
        <div id="dialogue-box">
            <div id="speaker"></div>
            <div id="dialogue-text"></div>
            <div id="choices"></div>
            
            <div id="user-input-container">
                <input type="text" id="user-input" placeholder="Введите свой ответ...">
                <button id="send-btn">Отправить</button>
            </div>
            
            <button id="regenerate-btn">Перегенерировать</button>
        </div>
        
        <div id="menu-button">☰</div>
        <div id="menu-dropdown">
            <textarea id="direct-request" placeholder="Прямой запрос к LLM..."></textarea>
            <button id="send-direct-btn">Отправить запрос</button>
        </div>
    </div>

    <!-- Character Modal -->
    <div class="modal" id="character-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Редактирование персонажа</h3>
                <button class="close-modal">&times;</button>
            </div>
            
            <div class="form-group">
                <label for="character-name">Имя персонажа</label>
                <input type="text" id="character-name">
            </div>
            
            <div class="form-group">
                <label for="character-description">Описание персонажа</label>
                <textarea id="character-description" rows="4"></textarea>
            </div>
            
            <div class="form-group">
                <label>Доступные спрайты</label>
                <div id="character-sprites-preview" style="margin-top: 1rem;"></div>
            </div>
            
            <button class="btn" id="save-character-btn">Сохранить</button>
        </div>
    </div>

    <!-- Location Modal -->
    <div class="modal" id="location-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Редактирование локации</h3>
                <button class="close-modal">&times;</button>
            </div>
            
            <div class="form-group">
                <label for="location-name">Название локации</label>
                <input type="text" id="location-name">
            </div>
            
            <div class="form-group">
                <label for="location-description">Описание локации</label>
                <textarea id="location-description" rows="4"></textarea>
            </div>
            
            <div class="form-group">
                <label>Изображение локации</label>
                <div id="location-preview" style="margin-top: 1rem; height: 200px; background-size: cover; background-position: center; border-radius: 10px;"></div>
            </div>
            
            <button class="btn" id="save-location-btn">Сохранить</button>
        </div>
    </div>

    <!-- Loading spinner -->
    <div id="loading">
        <div class="spinner"></div>
    </div>

    <script>
        // Game State
        const gameState = {
            characters: {},
            backgrounds: {},
            currentBackground: "",
            activeCharacters: {},
            dialogue: [],
            context: [],
            focusWindow: [], // Last 5 messages for context retention
            compressedHistory: "", // Compressed history of older messages
            settings: {
                model: "google/gemini-2.0-flash-thinking-exp:free",
                temperature: 0.2,
                maxTokens: 30000,
                apiKey: "",
                modes: {
                    romance: false,
                    cuteness: false,
                    cringe: false,
                    story: false
                },
                storyTitle: "",
                storyDescription: "",
                storyEvents: []
            },
            gameDay: 1,
            waitingForResponse: false,
            lastResponse: null
        };

        // DOM Elements
        const elements = {
            // Screens
            disclaimer: document.getElementById('disclaimer'),
            settings: document.getElementById('settings'),
            game: document.getElementById('game'),
            
            // Settings elements
            modelSelect: document.getElementById('model-select'),
            apiKey: document.getElementById('api-key'),
            temperature: document.getElementById('temperature'),
            tempValue: document.getElementById('temp-value'),
            maxTokens: document.getElementById('max-tokens'),
            romanceMode: document.getElementById('romance-mode'),
            cuteMode: document.getElementById('cute-mode'),
            cringeMode: document.getElementById('cringe-mode'),
            storyMode: document.getElementById('story-mode'),
            storyTitle: document.getElementById('story-title'),
            storyDescription: document.getElementById('story-description'),
            characterList: document.getElementById('character-list'),
            locationList: document.getElementById('location-list'),
            eventsContainer: document.getElementById('events-container'),
            
            // Game elements
            background: document.getElementById('background'),
            characters: document.getElementById('characters'),
            speaker: document.getElementById('speaker'),
            dialogueText: document.getElementById('dialogue-text'),
            choices: document.getElementById('choices'),
            userInput: document.getElementById('user-input'),
            sendBtn: document.getElementById('send-btn'),
            regenerateBtn: document.getElementById('regenerate-btn'),
            menuButton: document.getElementById('menu-button'),
            menuDropdown: document.getElementById('menu-dropdown'),
            directRequest: document.getElementById('direct-request'),
            sendDirectBtn: document.getElementById('send-direct-btn'),
            
            // Modals
            characterModal: document.getElementById('character-modal'),
            locationModal: document.getElementById('location-modal'),
            
            // Loading
            loading: document.getElementById('loading')
        };

        // Event Listeners
        document.getElementById('accept-btn').addEventListener('click', () => {
            elements.disclaimer.style.display = 'none';
            elements.settings.style.display = 'block';
            loadSettings();
            scanResources();
        });

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all tabs
                document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                
                // Add active class to clicked tab
                btn.classList.add('active');
                document.getElementById(`${btn.dataset.tab}-tab`).classList.add('active');
            });
        });

        // Temperature slider
        elements.temperature.addEventListener('input', () => {
            elements.tempValue.textContent = elements.temperature.value;
        });

        // Start game button
        document.getElementById('start-game-btn').addEventListener('click', () => {
            saveSettings();
            startGame();
        });

        // Menu toggle
        elements.menuButton.addEventListener('click', () => {
            elements.menuDropdown.style.display = elements.menuDropdown.style.display === 'none' ? 'block' : 'none';
        });

        // Add character button
        document.getElementById('add-character-btn').addEventListener('click', () => {
            openCharacterModal();
        });

        // Add location button
        document.getElementById('add-location-btn').addEventListener('click', () => {
            openLocationModal();
        });

        // Add event button
        document.getElementById('add-event-btn').addEventListener('click', () => {
            const eventInput = document.createElement('div');
            eventInput.className = 'form-group';
            eventInput.innerHTML = `<input type="text" class="story-event" placeholder="Событие, которое должно произойти...">`;
            elements.eventsContainer.appendChild(eventInput);
        });

        // Close modal buttons
        document.querySelectorAll('.close-modal').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.style.display = 'none';
                });
            });
        });

        // Save character button
        document.getElementById('save-character-btn').addEventListener('click', saveCharacter);

        // Save location button
        document.getElementById('save-location-btn').addEventListener('click', saveLocation);

        // Send user input
        elements.sendBtn.addEventListener('click', () => sendUserInput());
        elements.userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendUserInput();
        });

        // Regenerate button
        elements.regenerateBtn.addEventListener('click', regenerateResponse);

        // Send direct request
        elements.sendDirectBtn.addEventListener('click', sendDirectRequest);

        // Functions
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('vnSettings');
                if (savedSettings) {
                    const parsed = JSON.parse(savedSettings);
                    gameState.settings = {...gameState.settings, ...parsed};
                    
                    // Update UI
                    elements.modelSelect.value = gameState.settings.model;
                    elements.apiKey.value = gameState.settings.apiKey || '';
                    elements.temperature.value = gameState.settings.temperature;
                    elements.tempValue.textContent = gameState.settings.temperature;
                    elements.maxTokens.value = gameState.settings.maxTokens;
                    elements.romanceMode.checked = gameState.settings.modes.romance;
                    elements.cuteMode.checked = gameState.settings.modes.cuteness;
                    elements.cringeMode.checked = gameState.settings.modes.cringe;
                    elements.storyMode.checked = gameState.settings.modes.story;
                    elements.storyTitle.value = gameState.settings.storyTitle || '';
                    elements.storyDescription.value = gameState.settings.storyDescription || '';
                    
                    // Load characters
                    if (gameState.settings.characters) {
                        gameState.characters = gameState.settings.characters;
                        updateCharacterList();
                    }
                    
                    // Load backgrounds
                    if (gameState.settings.backgrounds) {
                        gameState.backgrounds = gameState.settings.backgrounds;
                        updateLocationList();
                    }
                    
                    // Load story events
                    if (gameState.settings.storyEvents && gameState.settings.storyEvents.length > 0) {
                        elements.eventsContainer.innerHTML = '';
                        gameState.settings.storyEvents.forEach(event => {
                            const eventInput = document.createElement('div');
                            eventInput.className = 'form-group';
                            eventInput.innerHTML = `<input type="text" class="story-event" value="${event}" placeholder="Событие, которое должно произойти...">`;
                            elements.eventsContainer.appendChild(eventInput);
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading settings:', error);
            }
        }

        function saveSettings() {
            try {
                gameState.settings.model = elements.modelSelect.value;
                gameState.settings.apiKey = elements.apiKey.value;
                gameState.settings.temperature = parseFloat(elements.temperature.value);
                gameState.settings.maxTokens = parseInt(elements.maxTokens.value);
                gameState.settings.modes.romance = elements.romanceMode.checked;
                gameState.settings.modes.cuteness = elements.cuteMode.checked;
                gameState.settings.modes.cringe = elements.cringeMode.checked;
                gameState.settings.modes.story = elements.storyMode.checked;
                gameState.settings.storyTitle = elements.storyTitle.value;
                gameState.settings.storyDescription = elements.storyDescription.value;
                
                // Save story events
                gameState.settings.storyEvents = [];
                document.querySelectorAll('.story-event').forEach(input => {
                    if (input.value.trim()) {
                        gameState.settings.storyEvents.push(input.value.trim());
                    }
                });
                
                // Save to localStorage
                gameState.settings.characters = gameState.characters;
                gameState.settings.backgrounds = gameState.backgrounds;
                localStorage.setItem('vnSettings', JSON.stringify(gameState.settings));
            } catch (error) {
                console.error('Error saving settings:', error);
            }
        }

        async function scanResources() {
            // In a real implementation, we would scan the directories
            // Since this is a static file and we can't access the filesystem directly
            // we'll mock the scanning process with a fetch to a manifest or use predefined lists
            
            try {
                // For demo purposes, we'll add some default resources
                // In a real implementation, this would fetch data from the server
                
                // Default characters
                if (!gameState.characters.Алиса) {
                    gameState.characters.Алиса = {
                        name: 'Алиса',
                        description: 'Активная и энергичная девушка с рыжими волосами. Спортивная, немного вспыльчивая, но добрая.',
                        sprites: ['normal.png', 'happy.png', 'angry.png', 'sad.png', 'surprised.png']
                    };
                }
                
                // Default backgrounds
                if (Object.keys(gameState.backgrounds).length === 0) {
                    gameState.backgrounds = {
                        'ВходВоротаВпионерлагерь': {
                            name: 'Вход в пионерлагерь',
                            description: 'Ворота лагеря с яркой вывеской "Добро пожаловать!"',
                            file: 'ВходВоротаВпионерлагерь.jpg'
                        },
                        'Пляж': {
                            name: 'Пляж',
                            description: 'Песчаный пляж на берегу озера',
                            file: 'Пляж.jpg'
                        },
                        'Столовая': {
                            name: 'Столовая',
                            description: 'Просторная столовая лагеря',
                            file: 'Столовая.jpg'
                        }
                    };
                }
                
                updateCharacterList();
                updateLocationList();
            } catch (error) {
                console.error('Error scanning resources:', error);
            }
        }

        function updateCharacterList() {
            elements.characterList.innerHTML = '';
            
            Object.values(gameState.characters).forEach(character => {
                const item = document.createElement('div');
                item.className = 'resource-item';
                item.innerHTML = `
                    <div class="resource-item-name">${character.name}</div>
                    <div class="resource-controls">
                        <button class="edit-btn" data-name="${character.name}">✏️</button>
                        <button class="delete-btn" data-name="${character.name}">🗑️</button>
                    </div>
                `;
                elements.characterList.appendChild(item);
            });
            
            // Add event listeners to edit and delete buttons
            document.querySelectorAll('.edit-btn').forEach(btn => {
                if (btn.parentElement.parentElement.parentElement.id === 'character-list') {
                    btn.addEventListener('click', () => {
                        openCharacterModal(btn.dataset.name);
                    });
                }
            });
            
            document.querySelectorAll('.delete-btn').forEach(btn => {
                if (btn.parentElement.parentElement.parentElement.id === 'character-list') {
                    btn.addEventListener('click', () => {
                        if (confirm(`Удалить персонажа ${btn.dataset.name}?`)) {
                            delete gameState.characters[btn.dataset.name];
                            updateCharacterList();
                        }
                    });
                }
            });
        }

        function updateLocationList() {
            elements.locationList.innerHTML = '';
            
            Object.values(gameState.backgrounds).forEach(location => {
                const item = document.createElement('div');
                item.className = 'resource-item';
                item.innerHTML = `
                    <div class="resource-item-name">${location.name}</div>
                    <div class="resource-controls">
                        <button class="edit-btn" data-name="${location.name}">✏️</button>
                        <button class="delete-btn" data-name="${location.name}">🗑️</button>
                    </div>
                `;
                elements.locationList.appendChild(item);
            });
            
            // Add event listeners to edit and delete buttons
            document.querySelectorAll('.edit-btn').forEach(btn => {
                if (btn.parentElement.parentElement.parentElement.id === 'location-list') {
                    btn.addEventListener('click', () => {
                        openLocationModal(btn.dataset.name);
                    });
                }
            });
            
            document.querySelectorAll('.delete-btn').forEach(btn => {
                if (btn.parentElement.parentElement.parentElement.id === 'location-list') {
                    btn.addEventListener('click', () => {
                        if (confirm(`Удалить локацию ${btn.dataset.name}?`)) {
                            const locationKey = Object.keys(gameState.backgrounds).find(
                                key => gameState.backgrounds[key].name === btn.dataset.name
                            );
                            if (locationKey) {
                                delete gameState.backgrounds[locationKey];
                                updateLocationList();
                            }
                        }
                    });
                }
            });
        }

        function openCharacterModal(characterName = null) {
            const modal = elements.characterModal;
            const nameInput = document.getElementById('character-name');
            const descriptionInput = document.getElementById('character-description');
            const spritesPreview = document.getElementById('character-sprites-preview');
            
            if (characterName && gameState.characters[characterName]) {
                const character = gameState.characters[characterName];
                nameInput.value = character.name;
                descriptionInput.value = character.description;
                
                // Display sprites
                spritesPreview.innerHTML = '';
                if (character.sprites && character.sprites.length > 0) {
                    character.sprites.forEach(sprite => {
                        const img = document.createElement('img');
                        img.src = `sprites/${characterName}/${sprite}`;
                        img.alt = sprite;
                        img.style.height = '100px';
                        img.style.margin = '5px';
                        img.style.border = '2px solid rgba(255,255,255,0.2)';
                        img.style.borderRadius = '5px';
                        spritesPreview.appendChild(img);
                    });
                } else {
                    spritesPreview.innerHTML = '<p>Нет доступных спрайтов</p>';
                }
                
                // Store original name for update
                nameInput.dataset.originalName = characterName;
            } else {
                nameInput.value = '';
                descriptionInput.value = '';
                spritesPreview.innerHTML = '<p>Нет доступных спрайтов. Создайте папку с именем персонажа в директории sprites и добавьте изображения.</p>';
                nameInput.dataset.originalName = '';
            }
            
            modal.style.display = 'flex';
        }

        function openLocationModal(locationName = null) {
            const modal = elements.locationModal;
            const nameInput = document.getElementById('location-name');
            const descriptionInput = document.getElementById('location-description');
            const preview = document.getElementById('location-preview');
            
            let locationKey = null;
            if (locationName) {
                locationKey = Object.keys(gameState.backgrounds).find(
                    key => gameState.backgrounds[key].name === locationName
                );
            }
            
            if (locationKey && gameState.backgrounds[locationKey]) {
                const location = gameState.backgrounds[locationKey];
                nameInput.value = location.name;
                descriptionInput.value = location.description;
                preview.style.backgroundImage = `url('backgrounds/${location.file}')`;
                nameInput.dataset.originalKey = locationKey;
            } else {
                nameInput.value = '';
                descriptionInput.value = '';
                preview.style.backgroundImage = 'none';
                preview.innerHTML = '<p style="padding: 20px; text-align: center;">Предпросмотр изображения</p>';
                nameInput.dataset.originalKey = '';
            }
            
            modal.style.display = 'flex';
        }

        function saveCharacter() {
            const nameInput = document.getElementById('character-name');
            const descriptionInput = document.getElementById('character-description');
            const originalName = nameInput.dataset.originalName;
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Имя персонажа не может быть пустым');
                return;
            }
            
            // If renaming, remove old entry
            if (originalName && originalName !== newName) {
                delete gameState.characters[originalName];
            }
            
            // Create or update character
            gameState.characters[newName] = {
                name: newName,
                description: descriptionInput.value.trim(),
                sprites: gameState.characters[originalName]?.sprites || []
            };
            
            updateCharacterList();
            elements.characterModal.style.display = 'none';
        }

        function saveLocation() {
            const nameInput = document.getElementById('location-name');
            const descriptionInput = document.getElementById('location-description');
            const originalKey = nameInput.dataset.originalKey;
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Название локации не может быть пустым');
                return;
            }
            
            // Generate a key from the name
            const newKey = newName.replace(/\s+/g, '');
            
            // If renaming, remove old entry
            if (originalKey && originalKey !== newKey) {
                delete gameState.backgrounds[originalKey];
            }
            
            // Create or update location
            gameState.backgrounds[newKey] = {
                name: newName,
                description: descriptionInput.value.trim(),
                file: gameState.backgrounds[originalKey]?.file || `${newKey}.jpg`
            };
            
            updateLocationList();
            elements.locationModal.style.display = 'none';
        }

        function startGame() {
            elements.settings.style.display = 'none';
            elements.game.style.display = 'block';
            
            // Set initial background
            setBackground('ВходВоротаВпионерлагерь');
            
            // Initialize game context
            initializeGameContext();
        }

        function setBackground(backgroundKey) {
            if (gameState.backgrounds[backgroundKey]) {
                const bg = gameState.backgrounds[backgroundKey];
                elements.background.style.backgroundImage = `url('backgrounds/${bg.file}')`;
                gameState.currentBackground = backgroundKey;
            }
        }

        function showCharacter(characterName, emotion = 'normal', position = 'center') {
            if (!gameState.characters[characterName]) return;
            
            // Check if character is already on screen
            let characterElement = document.querySelector(`.character[data-name="${characterName}"]`);
            
            if (!characterElement) {
                // Create new character element
                characterElement = document.createElement('div');
                characterElement.className = 'character';
                characterElement.dataset.name = characterName;
                elements.characters.appendChild(characterElement);
            }
            
            // Set position
            let posX = '50%';
            if (position === 'left') posX = '25%';
            if (position === 'right') posX = '75%';
            
            characterElement.style.left = posX;
            characterElement.style.transform = 'translateX(-50%)';
            
            // Set sprite
            const character = gameState.characters[characterName];
            let spriteFile = 'normal.png'; // Default
            
            if (character.sprites && character.sprites.includes(`${emotion}.png`)) {
                spriteFile = `${emotion}.png`;
            } else if (character.sprites && character.sprites.length > 0) {
                spriteFile = character.sprites[0];
            }
            
            characterElement.style.backgroundImage = `url('sprites/${characterName}/${spriteFile}')`;
            characterElement.style.backgroundSize = 'contain';
            characterElement.style.backgroundPosition = 'bottom center';
            characterElement.style.backgroundRepeat = 'no-repeat';
            
            // Make sure character is visible
            characterElement.style.opacity = '1';
            
            // Add to active characters
            gameState.activeCharacters[characterName] = {
                emotion: emotion,
                position: position
            };
        }

        function hideCharacter(characterName) {
            const characterElement = document.querySelector(`.character[data-name="${characterName}"]`);
            if (characterElement) {
                characterElement.style.opacity = '0';
                setTimeout(() => {
                    characterElement.remove();
                }, 500);
            }
            
            delete gameState.activeCharacters[characterName];
        }

        function typeText(text) {
            return new Promise(resolve => {
                elements.dialogueText.textContent = ''; // Clear previous text
                
                // Add each character with a delay
                let i = 0;
                const typingSpeed = 30; // ms per character
                
                function typeChar() {
                    if (i < text.length) {
                        elements.dialogueText.textContent += text.charAt(i);
                        i++;
                        setTimeout(typeChar, typingSpeed);
                    } else {
                        resolve();
                    }
                }
                
                typeChar();
            });
        }

        function showChoices(choices) {
            elements.choices.innerHTML = '';
            
            choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.textContent = choice;
                button.addEventListener('click', () => {
                    selectChoice(choice);
                });
                elements.choices.appendChild(button);
            });
        }

        function selectChoice(choice) {
            elements.choices.innerHTML = '';
            sendMessage(choice);
        }

        function initializeGameContext() {
            // Build the system prompt
            const systemPrompt = generateSystemPrompt();
            
            // Start the conversation
            sendSystemMessage(systemPrompt);
        }

        function generateSystemPrompt() {
            // Create the character list for the system prompt
            let charactersListText = '';
            Object.values(gameState.characters).forEach(character => {
                charactersListText += `${character.name}: ${character.description}\n`;
                charactersListText += `Доступные эмоции: ${character.sprites.map(s => s.replace('.png', '')).join(', ')}\n\n`;
            });
            
            // Create the backgrounds list
            let backgroundsListText = '';
            Object.values(gameState.backgrounds).forEach(bg => {
                backgroundsListText += `${bg.name}: ${bg.description}\n`;
            });
            
            // Build mode-specific instructions
            let modeInstructions = '';
            
            if (gameState.settings.modes.romance) {
                modeInstructions += 'Включай в сюжет романтические линии и возможность отношений между персонажами. ';
            }
            
            if (gameState.settings.modes.cuteness) {
                modeInstructions += 'Делай историю милой и позитивной, с акцентом на приятные моменты и дружеские отношения. ';
            }
            
            if (gameState.settings.modes.cringe) {
                modeInstructions += 'Добавляй неловкие и забавные ситуации, которые могут вызвать смущение у персонажей. ';
            }
            
            if (gameState.settings.modes.story) {
                modeInstructions += 'Следуй структуре истории с началом, развитием и кульминацией. История должна длиться 7 игровых дней. ';
                
                if (gameState.settings.storyEvents.length > 0) {
                    modeInstructions += 'Обязательно включи следующие события в повествование: ' + gameState.settings.storyEvents.join(', ') + '. ';
                }
            }
            
            // Put it all together
            return `
Ты являешься искусственным интеллектом, управляющим интерактивной визуальной новеллой. Твоя задача - создавать увлекательное повествование, управлять персонажами, сценами и развитием сюжета на основе выборов игрока.

### ФОРМАТ ОТВЕТОВ

Отвечай ИСКЛЮЧИТЕЛЬНО в JSON-формате:

{
  "messages": [
    {
      "text": "Текст диалога или повествования",
      "speaker": "имя_персонажа или narrator",
      "emotion": "эмоция_персонажа",
      "background": "фон_если_меняется",
      "sound": "звуковой_эффект_если_нужен",
      "position": "left/center/right",
      "choices": ["вариант1", "вариант2"]
    }
  ],
  "internal_notes": "Заметки для себя, не показываются игроку"
}

### ДОСТУПНЫЕ РЕСУРСЫ

## Персонажи
${charactersListText}

## Фоны
${backgroundsListText}

### ПАРАМЕТРЫ ИСТОРИИ

Название: ${gameState.settings.storyTitle || 'Летние приключения'}
Описание: ${gameState.settings.storyDescription || 'История о летнем отдыхе в пионерском лагере'}
Текущий день: ${gameState.gameDay} ${gameState.settings.modes.story ? '(из 7)' : ''}

${modeInstructions}

### ПРАВИЛА ПОВЕСТВОВАНИЯ

- Создавай эмоционально насыщенные диалоги, соответствующие характеру персонажей
- Развивай историю последовательно, учитывая предыдущие выборы игрока
- Предлагай выборы в ключевых моментах (не более 2-4 вариантов)
- Используй смену фонов для обозначения перемещений между локациями
- Меняй эмоции персонажей в соответствии с ситуацией
- Персонажи могут находиться в разных позициях: left, center, right

### НАЧАЛО ИСТОРИИ

Начни историю с прибытия в пионерский лагерь. Представь главного персонажа (игрока) и хотя бы одного второстепенного персонажа. Опиши обстановку, создай интригу или цель, которая будет мотивировать игрока продолжать историю.

### ОГРАНИЧЕНИЯ

- Все персонажи старше 21 года
- Не нарушай установленный сеттинг и жанр
- Отвечай строго в указанном JSON-формате для корректной работы игры
            `;
        }

        async function sendSystemMessage(message) {
            try {
                elements.loading.style.display = 'flex';
                
                const response = await callLLM(message, true);
                
                if (response) {
                    processLLMResponse(response);
                    gameState.context.push({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                }
                
                elements.loading.style.display = 'none';
            } catch (error) {
                console.error('Error in system message:', error);
                elements.loading.style.display = 'none';
                alert('Произошла ошибка при инициализации истории. Пожалуйста, проверьте API ключ и настройки.');
            }
        }

        async function sendMessage(message) {
            if (gameState.waitingForResponse) return;
            
            try {
                gameState.waitingForResponse = true;
                elements.loading.style.display = 'flex';
                
                // Add user message to context
                gameState.context.push({
                    role: 'user',
                    content: message
                });
                
                // Add to focus window for context management
                manageFocusWindow({
                    role: 'user',
                    content: message
                });
                
                const response = await callLLM();
                
                if (response) {
                    processLLMResponse(response);
                    
                    // Store the last response for potential regeneration
                    gameState.lastResponse = response;
                    
                    // Add to context and focus window
                    gameState.context.push({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                    
                    manageFocusWindow({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                }
                
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
            } catch (error) {
                console.error('Error in user message:', error);
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
                alert('Произошла ошибка при обработке сообщения.');
            }
        }

        async function sendUserInput() {
            const input = elements.userInput.value.trim();
            if (!input) return;
            
            elements.userInput.value = '';
            sendMessage(input);
        }

        async function regenerateResponse() {
            if (gameState.waitingForResponse) return;
            
            try {
                gameState.waitingForResponse = true;
                elements.loading.style.display = 'flex';
                
                // Remove the last assistant message from context
                if (gameState.context.length > 0 && gameState.context[gameState.context.length - 1].role === 'assistant') {
                    gameState.context.pop();
                }
                
                // Remove from focus window as well
                if (gameState.focusWindow.length > 0 && gameState.focusWindow[gameState.focusWindow.length - 1].role === 'assistant') {
                    gameState.focusWindow.pop();
                }
                
                const response = await callLLM();
                
                if (response) {
                    processLLMResponse(response);
                    
                    // Update the last response
                    gameState.lastResponse = response;
                    
                    // Add to context and focus window
                    gameState.context.push({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                    
                    manageFocusWindow({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                }
                
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
            } catch (error) {
                console.error('Error in regeneration:', error);
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
                alert('Произошла ошибка при перегенерации ответа.');
            }
        }

        async function sendDirectRequest() {
            if (gameState.waitingForResponse) return;
            
            const input = elements.directRequest.value.trim();
            if (!input) return;
            
            try {
                gameState.waitingForResponse = true;
                elements.loading.style.display = 'flex';
                elements.menuDropdown.style.display = 'none';
                
                // Add a special system message to guide the direct request
                const directSystemPrompt = `
Ты являешься искусственным интеллектом, управляющим интерактивной визуальной новеллой.
Игрок отправил тебе прямой запрос: "${input}"

Это специальный режим, в котором ты помогаешь игроку решить проблему или изменить ход истории.
Ответь в обычном JSON формате, как если бы это был следующий ход в истории.

Сделай свой ответ релевантным текущей ситуации в игре и постарайся учесть запрос игрока.
                `;
                
                // Create a temporary context for this request
                const tempContext = [
                    { role: 'system', content: directSystemPrompt },
                    ...gameState.context.slice(-5) // Include last 5 messages for context
                ];
                
                const response = await callLLM(undefined, false, tempContext);
                
                if (response) {
                    processLLMResponse(response);
                    
                    // Add this exchange to the regular context
                    gameState.context.push({
                        role: 'user',
                        content: `[Прямой запрос]: ${input}`
                    });
                    
                    gameState.context.push({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                    
                    // Manage focus window
                    manageFocusWindow({
                        role: 'user',
                        content: `[Прямой запрос]: ${input}`
                    });
                    
                    manageFocusWindow({
                        role: 'assistant',
                        content: JSON.stringify(response)
                    });
                }
                
                elements.directRequest.value = '';
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
            } catch (error) {
                console.error('Error in direct request:', error);
                gameState.waitingForResponse = false;
                elements.loading.style.display = 'none';
                alert('Произошла ошибка при обработке прямого запроса.');
            }
        }

        function manageFocusWindow(message) {
            // Add message to focus window
            gameState.focusWindow.push(message);
            
            // Keep only the last 5 messages in the focus window
            if (gameState.focusWindow.length > 5) {
                // Take the older messages and compress them
                const oldMessages = gameState.focusWindow.splice(0, gameState.focusWindow.length - 5);
                
                // In a real implementation, we would send these to be compressed
                // For now, we'll just create a simple summary
                const summary = oldMessages.map(m => {
                    if (m.role === 'user') {
                        return `Игрок: ${m.content}`;
                    } else if (m.role === 'assistant') {
                        try {
                            const parsed = JSON.parse(m.content);
                            return parsed.messages.map(msg => {
                                return `${msg.speaker}: ${msg.text}`;
                            }).join(' ');
                        } catch (e) {
                            return `Ассистент: ${m.content}`;
                        }
                    }
                    return '';
                }).join('\n');
                
                // Append to compressed history
                if (gameState.compressedHistory) {
                    gameState.compressedHistory += '\n\n';
                }
                gameState.compressedHistory += summary;
                
                // Check if we need to compress further
                if (gameState.compressedHistory.length > 10000) {
                    // In a real implementation, we would super-compress the history
                    // For now, we'll just keep the most recent part
                    gameState.compressedHistory = gameState.compressedHistory.slice(-5000);
                    gameState.compressedHistory = "Сжатая история предыдущих событий:\n" + gameState.compressedHistory;
                }
            }
        }

        async function callLLM(systemPrompt = undefined, isSystemMessage = false, customContext = null) {
            const apiKey = gameState.settings.apiKey;
            if (!apiKey) {
                alert('Пожалуйста, введите API ключ OpenRouter в настройках.');
                return null;
            }
            
            try {
                let messages = [];
                
                if (customContext) {
                    // Use custom context if provided (for direct requests)
                    messages = customContext;
                } else {
                    // For system initialization
                    if (isSystemMessage) {
                        messages = [
                            { role: 'system', content: systemPrompt }
                        ];
                    } else {
                        // For regular messages, include compressed history and focus window
                        let contextPrompt = generateSystemPrompt();
                        
                        if (gameState.compressedHistory) {
                            contextPrompt += '\n\n### СЖАТАЯ ИСТОРИЯ ПРЕДЫДУЩИХ СОБЫТИЙ\n' + gameState.compressedHistory;
                        }
                        
                        messages = [
                            { role: 'system', content: contextPrompt },
                            ...gameState.focusWindow // Include only the focus window messages
                        ];
                    }
                }
                
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: gameState.settings.model,
                        messages: messages,
                        temperature: gameState.settings.temperature,
                        max_tokens: gameState.settings.maxTokens
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${JSON.stringify(errorData)}`);
                }
                
                const data = await response.json();
                let content = data.choices[0].message.content;
                
                try {
                    // Try to parse as JSON
                    return JSON.parse(content);
                } catch (e) {
                    // If it's not valid JSON, try to extract JSON part
                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            return JSON.parse(jsonMatch[0]);
                        } catch (e2) {
                            console.error('Failed to parse JSON from response:', content);
                            throw new Error('Получен некорректный формат ответа от LLM.');
                        }
                    } else {
                        console.error('No JSON found in response:', content);
                        throw new Error('Получен некорректный формат ответа от LLM.');
                    }
                }
            } catch (error) {
                console.error('API Error:', error);
                throw error;
            }
        }

        async function processLLMResponse(response) {
            try {
                if (!response.messages || !Array.isArray(response.messages)) {
                    throw new Error('Некорректный формат ответа от LLM');
                }
                
                // Process each message
                for (const message of response.messages) {
                    // Set background if specified
                    if (message.background) {
                        // Find the background key by name
                        const backgroundKey = Object.keys(gameState.backgrounds).find(
                            key => gameState.backgrounds[key].name === message.background
                        ) || message.background;
                        
                        setBackground(backgroundKey);
                    }
                    
                    // Update speaker name
                    elements.speaker.textContent = message.speaker === 'narrator' ? '' : message.speaker;
                    
                    // Show character if it's a character speaking
                    if (message.speaker && message.speaker !== 'narrator') {
                        const position = message.position || 'center';
                        const emotion = message.emotion || 'normal';
                        showCharacter(message.speaker, emotion, position);
                    }
                    
                    // Display text with typewriter effect
                    await typeText(message.text);
                    
                    // Show choices if any
                    if (message.choices && message.choices.length > 0) {
                        showChoices(message.choices);
                    }
                    
                    // Wait for user interaction if choices are shown
                    if (message.choices && message.choices.length > 0) {
                        // Don't continue to next message if choices are presented
                        break;
                    }
                    
                    // Add a small delay between messages for readability
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            } catch (error) {
                console.error('Error processing LLM response:', error);
                alert('Произошла ошибка при обработке ответа LLM.');
            }
        }
    </script>
</body>
</html>